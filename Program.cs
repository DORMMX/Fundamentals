using Fundamentals;
using System;
using static Fundamentals.CreacionTipoDatos;

//TODO: Add documentation to classes and methods automatically generated by the C# extension in Visual Studio Code

//Stack_Heap
Stack_Heap.Stack();
Stack_Heap.Heap();

//-----------------------------------------------Funtions------------------------------------------------
//1.Ref
int miNumero = 5; // La variable debe estar inicializada
Console.WriteLine($"Antes de llamar al método: {miNumero}");
Funtions.RefParameter(ref miNumero); // Pasamos por referencia
Console.WriteLine($"Después de llamar al método: {miNumero}"); // El cambio se refleja aquí

//2. Out
int longitudLado = 7;
int miArea;    // No necesita inicialización
int miPerimetro; // No necesita inicialización
// C# 7.0 y versiones posteriores permiten declarar la variable inline
// CalcularAreaYPerimetro(longitudLado, out int miArea, out int miPerimetro);
Funtions.OutParameter(longitudLado, out miArea, out miPerimetro); // Pasamos por referencia
Console.WriteLine($"Después de llamar al método - Área: {miArea}, Perímetro: {miPerimetro}");
 
//3. Params
int resultado1 = Funtions.ParamsFunction(10, 20, 30);
Console.WriteLine($"La suma de 10, 20 y 30 es: {resultado1}"); // Salida: 60

//------------------------------------------Creacion de Tipos Datos -------------------------------------------------
//1. Structs
DiaDeLaSemana hoy = DiaDeLaSemana.Miercoles;
Console.WriteLine($"Hoy es: {hoy}"); // Salida: Hoy es: Miercoles
// Puedes castear un enum a su valor numérico
Console.WriteLine($"El valor numérico de Miercoles es: {(int)hoy}"); // Salida: 2                                                                    // Comparaciones
if (hoy == DiaDeLaSemana.Miercoles)
{
    Console.WriteLine("¡Estamos a mitad de semana!");
}

//2.Structs
// Creación de una struct
Punto2D p1 = new(10, 20);
Console.WriteLine($"Punto 1 inicial: {p1}"); // Salida: (10, 20)
// Asignación de struct: se crea una COPIA
Punto2D p2 = p1;
Console.WriteLine($"Punto 2 inicial (copia de P1): {p2}"); // Salida: (10, 20)
// Modificamos p2
p2.Mover(5, -5);
Console.WriteLine($"Punto 2 después de mover: {p2}"); // Salida: (15, 15)
// p1 NO ha sido afectada porque p2 es una copia
Console.WriteLine($"Punto 1 después de modificar P2: {p1}"); // Salida: (10, 20)

//3. Clases : Una class es el bloque de construcción fundamental de la programación orientada a objetos en C#. Las clases son tipos de referencia, lo que significa que las variables de una clase no contienen el objeto en sí,
//sino una referencia (una dirección en memoria) a donde el objeto está almacenado.

// En resumen, la elección entre struct y class depende principalmente de si necesitas un tipo de valor (copia de datos) o un tipo de referencia (referencia al mismo objeto). 
// Los enum son para un propósito muy específico de definir constantes con nombre.

//------------------------------------------Tipos de Conversiones de Datos -------------------------------------------------

//Implicitas: Son conversiones automáticas que el compilador realiza sin necesidad de intervención del programador. Se utilizan cuando no hay pérdida de datos y la conversión es segura.

// 1. Implicitas
// 1.A) int a long (long puede contener todos los valores de int)
int miEntero = 100;
long miLong = miEntero; // Conversión implícita
Console.WriteLine($"int a long: {miEntero} -> {miLong}"); // Salida: 100 -> 100
// 1.B) float a double (double tiene mayor precisión que float)
float miFlotante = 123.45f;
double miDoble = miFlotante; // Conversión implícita
Console.WriteLine($"float a double: {miFlotante} -> {miDoble}"); // Salida: 123.45 -> 123.45000457763672
// 1.C) Tipos derivados a tipos base (Polimorfismo)
// string es una clase que hereda de object
string miCadena = "Hola";
object miObjeto = miCadena; // Conversión implícita
Console.WriteLine($"string a object: {miCadena} -> {miObjeto}"); // Salida: Hola -> Hola

// 2. Explicitas: Son conversiones que requieren intervención del programador porque pueden implicar pérdida de datos o no son seguras. Se utilizan cuando se necesita convertir un tipo de dato a otro que no es compatible directamente.
// 2.A) long a int (posible pérdida de datos si el long es muy grande)
long miLongNormal = 150;
int miEnteroNormal = (int)miLongNormal; // Conversión explícita
Console.WriteLine($"long a int (normal): {miLongNormal} -> {miEnteroNormal}"); // Salida: 150 -> 150
// 2.B) double a float (posible pérdida de precisión)
double miDoblePrecision = 123.456789;
float miFlotanteReducido = (float)miDoblePrecision; // Conversión explícita, pierde precisión
Console.WriteLine($"double a float: {miDoblePrecision} -> {miFlotanteReducido}"); // Salida: 123.456789 -> 123.4568
// 2.C) object a tipo derivado (posible error si el objeto no es del tipo esperado)
object miObjetoNumerico = 250;
// int miOtroEntero = (string)miObjetoNumerico; // Error de tiempo de ejecución (InvalidCastException)
int miEnteroDesdeObjeto = (int)miObjetoNumerico; // Conversión explícita
Console.WriteLine($"object a int: {miObjetoNumerico} -> {miEnteroDesdeObjeto}"); // Salida: 250 -> 250
// Uso del operador 'as' para conversiones seguras de referencia
// 'as' devuelve null si la conversión falla, no lanza excepción
string? cadenaObj = miObjetoNumerico as string;
Console.WriteLine($"object a string con 'as': {(cadenaObj ?? "null")}"); // Salida: null
// Uso del operador 'is' para verificar tipo antes de castear
if (miObjetoNumerico is int)
{
    int valorVerificado = (int)miObjetoNumerico;
    Console.WriteLine($"object es int: {valorVerificado}"); // Salida: 250
}

// 3. Conversión entre tipos definidos por el usuario (structs y clases)
// Ejemplo de Conversión IMPLÍCITA (Punto a Coordenada)
Punto Pa1 = new Punto(1000, 2000);
Coordenada c1 = Pa1; // No se requiere cast porque definimos 'implicit operator'
Console.WriteLine($"Punto a Coordenada (implícita): {Pa1} -> {c1}");
// Salida: Punto(1000, 2000) -> Coordenada(10.00, 20.00)

// Ejemplo de Conversión EXPLÍCITA (Coordenada a Punto)
Coordenada c2 = new Coordenada(35.5, -78.9);
Punto Pa2 = (Punto)c2; // Se requiere cast porque definimos 'explicit operator'
Console.WriteLine($"Coordenada a Punto (explícita): {c2} -> {Pa2}");
// Salida: Coordenada(35.50, -78.90) -> Punto(3550, -7890)

// Ejemplo de Conversión EXPLÍCITA (Punto a int)        
int xCoord = (int)Pa1; // Se requiere cast porque definimos 'explicit operator'
Console.WriteLine($"Punto a int (explícita - solo X): {Pa1} -> {xCoord}");
// Salida: Punto(1000, 2000) -> 1000    